# 实验1.1

## 算法主要思想

A*算法

通过不断对节点的一致性代价g(n)和h(n)相加得到评估结果eval，然后不断选择eval最小的节点进行拓展，来搜索整个状态空间，如果达到目标状态，则为最优解，返回结果节点并返回路径。在此过程中，使用`closed_list`记录已经访问过的节点。如果expand得到的结果eval在closed_list中存在，且小于closed_list中的节点eval,需要从closed_list中消除该点并重新添加到open_list中。如果expand得到的节点在open_list中，且比open_list中的eval要小，则也需要从open_list中删除eval大的节点并插入新节点。

IDA*算法

在A*算法的基础上添加深度受限的条件。在给定受限深度d_limit的情况下，通过比较g(n)(这里g(n)就代表深度)和受限深度d_limit来判断节点a是否要进行拓展，如果g(n)>d_limit，则不进行拓展，而是转到其他g(n) < d_limit深度的节点进行拓展，等到d_limit增大后再访问这个二级点。然后受限深度d_limit不断增大，加深，直到搜索到最优解。在此过程中不清空open_list,而是在下一个迭代中继续使用现有结果。

自己的启发式函数是除了0之外，其他非黑洞数字距离目标位置的“循环曼哈顿距离”。由于存在时空隧道，普通的曼哈顿距离在这里无法适用。因此采用所谓的“循环曼哈顿距离”，也就是如下图所示。

![](image/示意图.jpg)

由于穿越时空隧道相当于取模操作，所以可以使用`min{|x1-x2|,5-|x1-x2|}+min{|y1-y2,5-|y1-y2|}`的方式求得循环曼哈顿距离。由于每个节点只能通过0进行替换，而且还存在隧道弯路(即源和目标在隧道的同一侧的情况)，所以该启发式函数是admissible的

## 运行结果


## 优化方法

运行时间上，如果一个节点a状态在open_list中已经出现，但是评估结果 > open_list中的那个节点的eval，则删除open_list中的那个节点，将a节点添加到open_list中，这样可以避免一些eval较大的节点的不必要插入。如果节点a在closed_list中出现，而且也比closed_list中的eval要大，则也删除该节点。

另外，在输入时就将每个点能够走的方向确定下来，之后在进行expand生成后继节点时只要进行查询即可。

最重要的一点优化是在进行expand时，根据生成该节点时采用的方向，不生成反方向的节点，因为反方向一定是没有用的。如果从上往下走，则扩展节点一定不会从下回到上。该优化将时间从大概190s降低至5,6s

# 实验1.2
