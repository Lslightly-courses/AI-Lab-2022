# 实验1.1

## 算法主要思想

A*算法

通过不断对节点的一致性代价g(n)和h(n)相加得到评估结果eval，然后不断选择eval最小的节点进行拓展，来搜索整个状态空间，如果达到目标状态，则为最优解，返回结果节点并返回路径

IDA*算法

在A*算法的基础上添加深度受限的条件。在给定受限深度d_limit的情况下，通过比较g(n)(这里g(n)就代表深度)和受限深度d_limit来判断节点a是否要进行拓展，如果g(n)>d_limit，则不进行拓展，而是转到其他g(n) < d_limit深度的节点进行拓展，等到d_limit增大后再访问这个二级点。然后受限深度d_limit不断增大，加深，直到搜索到最优解。

## 运行结果

A_h1

A_h2

IDA_h1

IDA_h2


## 优化方法

运行时间上，如果一个节点a状态在open_list中已经出现，但是评估结果 < open_list中的那个节点的eval，则删除open_list中的那个节点，将a节点添加到open_list中，这样可以避免一些eval较大的节点的不必要插入

运行空间上，传统算法中由于traceback得到结果需要保留所有节点，因此会有较大的空间浪费，在我的实现中，每个节点c根据父节点p的继承路径path以及父节点p状态转变到节点c的状态的决策direction拼接得到节点c的traceback，此时父节点p已经没有用了，而且p已经从open_list中弹出，因此p可以直接释放，而不需要保留。在运行时最大空间上有优化。

# 实验1.2
